use serde::{Deserialize, Serialize};

/// Version tag used by both the host and the device when negotiating sync messages.
pub const PROTOCOL_VERSION: u16 = 1;

/// Host initiated requests travelling from the CLI to the device during a sync session.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub enum HostRequest {
    /// Request the device to stream its latest vault back to the host.
    PullVault(PullVaultRequest),
    /// Confirm that a sequence of journal frames has been applied successfully by the host.
    AckPush(PushAck),
    /// Abort the current sync session with an explicit reason.
    Abort(AbortRequest),
}

/// Responses sent by the device back to the host during a sync session.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub enum DeviceResponse {
    /// A batch of journal operations produced by the device for the host to apply.
    JournalFrame(JournalFrame),
    /// A chunk of the encrypted vault streamed from the device.
    VaultChunk(VaultChunk),
    /// Final status after completing a sync phase.
    Completed(SyncCompletion),
    /// Failure reported by the device while handling the previous host request.
    Error(DeviceError),
}

/// Metadata accompanying the host request to pull the vault from the device.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct PullVaultRequest {
    /// Version of the protocol expected by the host for this request.
    pub protocol_version: u16,
    /// Maximum number of payload bytes that fit in the host receive buffer.
    pub host_buffer_size: u32,
    /// Largest chunk size (in bytes) that the host can process per frame.
    pub max_chunk_size: u32,
    /// Generation number known by the host to detect stale device state.
    pub known_generation: Option<u64>,
}

/// Host acknowledgement that a push flow journal was persisted successfully.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct PushAck {
    /// Version of the protocol used by the host for the acknowledgement.
    pub protocol_version: u16,
    /// Sequential identifier that matches the last processed journal frame.
    pub last_frame_sequence: u32,
    /// Rolling CRC32 of the journal payloads applied by the host.
    pub journal_checksum: u32,
}

/// Host initiated abort with a human readable context.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct AbortRequest {
    /// Version of the protocol understood by the host when issuing the abort.
    pub protocol_version: u16,
    /// Reason for the abort so the device can render an error message.
    pub reason: AbortReason,
}

/// Canonical abort reasons supported by the host implementation.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub enum AbortReason {
    /// Host detected an unrecoverable transport or decoding error.
    TransportFailure,
    /// Vault verification failed on the host side.
    VerificationFailed,
    /// Operator cancelled the sync flow manually.
    UserCancelled,
}

/// Journal data generated by the device and consumed by the host.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct JournalFrame {
    /// Version of the protocol used by the device for this frame.
    pub protocol_version: u16,
    /// Sequence number that allows the host to reassemble frames in order.
    pub sequence: u32,
    /// Number of operations still queued after this frame.
    pub remaining_operations: u32,
    /// Journal operations describing vault changes since the previous sync.
    pub operations: Vec<JournalOperation>,
    /// CRC32 computed over the encoded journal operations to guard against corruption.
    pub checksum: u32,
}

/// Supported journal operations derived from the sync specification.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub enum JournalOperation {
    /// A new vault entry has been inserted.
    Add { entry_id: String },
    /// A single field of an existing entry has been updated.
    UpdateField {
        /// Identifier of the entry being modified.
        entry_id: String,
        /// Logical field path (e.g. "service", "username").
        field: String,
        /// CRC32 of the updated value allowing the host to detect mismatches.
        value_checksum: u32,
    },
    /// A vault entry was removed on the device.
    Delete { entry_id: String },
}

/// Chunk of the encrypted vault payload streamed to the host.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct VaultChunk {
    /// Version of the protocol carried by the chunk metadata.
    pub protocol_version: u16,
    /// Position of the chunk within the transfer.
    pub sequence: u32,
    /// Total size in bytes of the complete artifact being transferred.
    pub total_size: u64,
    /// Number of bytes still remaining after this chunk.
    pub remaining_bytes: u64,
    /// Maximum chunk size that the device can emit for the session.
    pub device_chunk_size: u32,
    /// Raw encrypted data payload from the vault artifact.
    pub data: Vec<u8>,
    /// CRC32 protecting the payload bytes in this chunk.
    pub checksum: u32,
    /// Whether this chunk finalises the artifact transfer.
    pub is_last: bool,
}

/// Status emitted when the device finalises a sync phase.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct SyncCompletion {
    /// Protocol version agreed for the session.
    pub protocol_version: u16,
    /// Total number of frames sent during the completed phase.
    pub frames_sent: u32,
    /// CRC32 of the entire payload stream seen by the device.
    pub stream_checksum: u32,
}

/// Describes an error condition detected by the device.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct DeviceError {
    /// Protocol version in use when the error was detected.
    pub protocol_version: u16,
    /// Stable error code for programmatic handling.
    pub code: DeviceErrorCode,
    /// Human readable description intended for logs.
    pub message: String,
}

/// Enumerates error codes that can be produced by the device.
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub enum DeviceErrorCode {
    /// Host provided stale metadata or generation number.
    StaleGeneration,
    /// Payload checksum validation failed.
    ChecksumMismatch,
    /// Device resources (buffer, storage) are exhausted.
    ResourceExhausted,
    /// Any other unrecoverable internal failure.
    InternalFailure,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn host_request_roundtrip() {
        let request = HostRequest::PullVault(PullVaultRequest {
            protocol_version: PROTOCOL_VERSION,
            host_buffer_size: 64 * 1024,
            max_chunk_size: 4096,
            known_generation: Some(42),
        });

        let encoded = serde_cbor::to_vec(&request).expect("encode");
        let decoded: HostRequest = serde_cbor::from_slice(&encoded).expect("decode");

        assert_eq!(decoded, request);
    }

    #[test]
    fn device_response_roundtrip() {
        let response = DeviceResponse::JournalFrame(JournalFrame {
            protocol_version: PROTOCOL_VERSION,
            sequence: 1,
            remaining_operations: 0,
            operations: vec![JournalOperation::UpdateField {
                entry_id: "entry-1".to_string(),
                field: "username".to_string(),
                value_checksum: 0xDEADBEEF,
            }],
            checksum: 0xABCD1234,
        });

        let encoded = serde_cbor::to_vec(&response).expect("encode");
        let decoded: DeviceResponse = serde_cbor::from_slice(&encoded).expect("decode");

        assert_eq!(decoded, response);
    }

    #[test]
    fn vault_chunk_roundtrip() {
        let chunk = DeviceResponse::VaultChunk(VaultChunk {
            protocol_version: PROTOCOL_VERSION,
            sequence: 3,
            total_size: 1024,
            remaining_bytes: 256,
            device_chunk_size: 512,
            data: vec![1, 2, 3, 4, 5],
            checksum: 0x12345678,
            is_last: false,
        });

        let encoded = serde_cbor::to_vec(&chunk).expect("encode");
        let decoded: DeviceResponse = serde_cbor::from_slice(&encoded).expect("decode");

        assert_eq!(decoded, chunk);
    }

    #[test]
    fn device_error_roundtrip() {
        let error = DeviceResponse::Error(DeviceError {
            protocol_version: PROTOCOL_VERSION,
            code: DeviceErrorCode::ChecksumMismatch,
            message: "checksum mismatch".into(),
        });

        let encoded = serde_cbor::to_vec(&error).expect("encode");
        let decoded: DeviceResponse = serde_cbor::from_slice(&encoded).expect("decode");

        assert_eq!(decoded, error);
    }
}
