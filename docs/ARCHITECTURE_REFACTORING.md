# Architecture Refactoring Assessment

## Tooling snapshot
- `cargo machete` – verified that no crates contain unused dependencies in the current workspace.【e5d2fd†L1-L3】
- `cargo +nightly udeps` – required switching to the nightly toolchain; run completed after compiling all crates. The shared vault cipher triggered unused-assignment warnings that should be addressed during follow-up refactors.【e38894†L1-L10】
- `cargo +nightly fmt -- --unstable-features --skip-children` – ensured formatting consistency without rewriting generated schema files.【5c9c62†L1-L2】

## Ripgrep duplicate findings
The following `rg` probes were used to spot cross-crate duplication and hotspots:

- `rg -n "FrameHeader" -g '*.rs'` highlighted that CDC header encoding/decoding logic lives in both `firmware` and `host-cli` in addition to the shared definition, driving transport-level duplication.【95ccf9†L1-L17】
- `rg -n "accumulate_checksum" -g '*.rs'` confirmed that both `firmware` and `host-cli` reimplement the same checksum folding for journal operations even though the utility already lives under `shared::checksum`.【3d842c†L1-L16】
- `rg -n "command_for_request" -n host-cli/src/main.rs` versus the same pattern inside `firmware` showed literal copy/paste of CDC command routing in both binaries.【9b9337†L1-L4】【83263c†L1-L30】
- `rg -n "JournalOperation" -g '*.rs'` mapped every layer translating vault updates across host CLI helpers, shared vault storage primitives, and firmware side bookkeeping, revealing additional opportunities for consolidation.【e5f565†L1-L33】

## Shared utilities and API overlaps
| Area | Shared source | Host CLI usage | Firmware usage | Consolidation notes |
| --- | --- | --- | --- | --- |
| CDC frame schema (`CdcCommand`, `FrameHeader`, CRC) | `shared/src/cdc.rs` defines the frame layout, conversion traits, and CRC helper used during USB CDC exchanges.【F:shared/src/cdc.rs†L1-L139】 | The CLI imports the CDC types at the top of `main.rs` to wrap every request/response sent over the serial port.【F:host-cli/src/main.rs†L1-L41】 `command_for_request/response` are reimplemented locally, duplicating the mapping that could live beside the schema.【F:host-cli/src/main.rs†L1632-L1657】 | Firmware likewise imports the same CDC primitives and then repeats the mapping helpers plus checksum validation inside `lib.rs`.【F:firmware/src/lib.rs†L90-L101】【F:firmware/src/lib.rs†L1540-L1602】 | Extract `command_for_request/response` and checksum validation helpers into a `shared::cdc::transport` module consumed by both binaries to guarantee parity and shrink large files. |
| Rolling checksum utilities | `shared/src/checksum.rs` exposes `accumulate_checksum` with a documented FNV-like fold tailored to vault journals.【F:shared/src/checksum.rs†L1-L30】 | The CLI computes local journal checksums before pushing operations to the device, duplicating the fold inline.【F:host-cli/src/main.rs†L1015-L1034】 | Firmware uses the same algorithm to track outgoing journal streams, repeating the fold inline as well.【F:firmware/src/lib.rs†L1225-L1243】 | A shared helper that accepts device vs host operation enums would avoid divergent implementations and simplify testing. |
| Vault schema & encryption | `shared/src/vault/model.rs` defines vault metadata, entries, and journal operations, while `shared/src/vault/cipher.rs` and `storage.rs` provide AEAD envelopes and flash persistence utilities.【F:shared/src/vault/model.rs†L1-L133】【F:shared/src/vault/cipher.rs†L1-L127】【F:shared/src/vault/storage.rs†L1-L160】 | The CLI pulls `EntryUpdate`, `VaultEntry`, and `PageCipher` to read/write snapshots, but maintains its own `VaultSnapshot` type and high-level encrypt/decrypt helpers near line 2020.【F:host-cli/src/main.rs†L21-L69】【F:host-cli/src/main.rs†L2020-L2069】 | Firmware reimplements ChaCha20-Poly1305 usage and journal persistence directly in `lib.rs` instead of layering on `PageCipher`/`VaultJournal`.【F:firmware/src/lib.rs†L13-L118】【F:firmware/src/lib.rs†L1180-L1258】 | Promote `VaultSnapshot` + encrypt/decrypt helpers into `shared::vault`, then reuse them from both binaries; firmware could also wrap its flash writes around `VaultJournal` to align storage semantics. |
| Schema codec + error handling | `shared/src/schema.rs` (generated) plus `shared/src/error.rs` wrap postcard codecs and a transport-friendly error enum.【F:shared/src/error.rs†L1-L16】 | The CLI maps IO and serde errors into `SharedError` so every command path returns a unified error to the user.【F:host-cli/src/main.rs†L20-L34】 | Firmware currently defines its own `ProtocolError` tree and manually converts codec failures, even though the shared codec already produces typed errors.【F:firmware/src/lib.rs†L1525-L1602】 | Introducing a shared `ProtocolError` (or reusing `SharedError` in firmware) would avoid bespoke error conversions and better align host/device logging. |

## Module size versus <300 LOC guideline
| File | LOC | Notes |
| --- | --- | --- |
| `host-cli/src/main.rs` | 3,210 | Monolithic binary that combines CLI parsing, serial transport, repo access, and cryptography; far exceeds the suggested <300 LOC target.【74bc83†L1-L2】 |
| `firmware/src/lib.rs` | 3,259 | Contains protocol state machine, crypto, storage, and UI plumbing in a single file, making it difficult to isolate refactors.【40efe3†L1-L12】 |
| `firmware/src/ui/state.rs` | 820 | UI state container alone is nearly 3× the 300 LOC goal, signalling the need for submodules/components.【40efe3†L7-L12】 |
| `firmware/src/ui/render.rs` | 168 | Within the limit but tightly coupled to the oversized state module.【40efe3†L7-L12】 |
| `firmware/src/ui/input.rs` | 230 | Approaching the limit; already contains multiple responsibilities.【40efe3†L7-L12】 |
| `shared/src/vault/storage.rs` | 412 | Long due to async flash orchestration and should be split into encoder vs driver modules for readability.【e58ae4†L1-L5】 |
| `shared/src/vault/model.rs` | 277 | Just under the limit; further growth should trigger a split between schema structs and helpers.【e58ae4†L1-L5】 |
| `shared/src/cdc.rs` | 140 | Comfortable size and a good candidate to host more shared transport helpers.【40efe3†L1-L6】 |

## Refactor candidates
| Candidate | Scope & rationale | Effort | Impact |
| --- | --- | --- | --- |
| Shared CDC transport helpers | Move `command_for_request`, `command_for_response`, frame checksum validation, and frame encode/decode helpers into `shared::cdc` so both binaries consume the same logic. This removes redundant code from two 3k LOC files and ensures protocol drift cannot happen silently.【F:host-cli/src/main.rs†L1632-L1657】【F:firmware/src/lib.rs†L1540-L1602】 | Medium – requires adding a new module and updating both crates to call it. | High – immediately reduces duplicated code paths and centralizes protocol validation. |
| Journal checksum + operation folding library | Introduce a typed adapter (e.g., `shared::journal`) that accepts either device or host journal enums and emits checksums/flattened operations, replacing bespoke folds and conversion logic in both binaries.【F:host-cli/src/main.rs†L1015-L1034】【F:firmware/src/lib.rs†L1225-L1243】 | Medium – need shared traits plus migration of existing helpers. | Medium – improves testability and makes host/firmware journal integrity consistent. |
| Vault snapshot & crypto module | Promote `VaultSnapshot`, encrypt/decrypt helpers, and host-side file IO glue into `shared::vault`, then call the same code when the firmware serializes or ingests vault payloads instead of open-coding ChaCha20-Poly1305 usage.【F:host-cli/src/main.rs†L2020-L2069】【F:firmware/src/lib.rs†L13-L118】 | High – touches both storage pipelines and may require feature-gating std vs no_std. | High – consolidates crypto, reduces attack surface, and simplifies proving parity between host archives and firmware expectations. |
| Host CLI module split | Break `host-cli/src/main.rs` into dedicated modules (`cli`, `transport`, `journal`, `repo`) so each stays well under 300 LOC and dependencies (serialport, filesystem, crypto) are isolated. | Medium/High – mainly an organizational change but touches most functions. | Medium – easier reviews, enables targeted unit tests, and unlocks reuse of transport module by future GUIs. |
| Firmware UI state partitioning | Split `firmware/src/ui/state.rs` into smaller components (input handling, rendering model, transport bindings) and replace the current monolith with composable structs. | Medium – mostly reshuffling but must respect embedded memory constraints. | Medium – reduces compile times and allows partial reuse for future display modes. |
| shared::vault storage layering | Break `shared/src/vault/storage.rs` into `driver` vs `codec` modules and expose a trait for firmware-side flash so that new backends (e.g., host simulations) can reuse the same logic without copy/paste. | Medium – restructure module and adjust imports. | Medium – clarifies the boundary between flash IO and envelope encoding, improving maintainability. |
